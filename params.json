{
  "name": "Komada",
  "tagline": "Komada: Croatian for `pieces`, is a modular bot system including reloading modules and easy to use custom commands.",
  "body": "# Komada\r\n\r\n[![Discord](https://discordapp.com/api/guilds/234357395646578688/embed.png)](https://discord.gg/bRCvFy9)\r\n[![npm](https://img.shields.io/npm/v/komada.svg?maxAge=3600)](https://www.npmjs.com/package/komada)\r\n[![npm](https://img.shields.io/npm/dt/komada.svg?maxAge=3600)](https://www.npmjs.com/package/komada)\r\n[![David](https://img.shields.io/david/eslachance/komada.svg?maxAge=3600)](https://david-dm.org/eslachance/komada)\r\n\r\n> \"Stay a while, and listen!\"\r\n\r\nKomada is a modular framework for bots built on top of [Discord.js](https://github.com/hydrabolt/dicord.js). It offers an extremely easy installation, downloadable commands, and a framework to build your own commands, modules, and functions.\r\n\r\n## Installing Komada\r\n\r\nTime to take the plunge! Komada is on NPM and can be easily installed.\r\n\r\n> I assume you know how to open a command prompt in a folder where you want to install this. Please don't prove me wrong.\r\n\r\n```\r\nnpm install --save komada\r\n```\r\n\r\nCreate a file called `app.js` (or whatever you prefer) which will initiate and configure Komada.\r\n\r\n```js\r\nconst komada = require('komada');\r\nkomada.start({\r\n  \"botToken\": \"your-bot-token\",\r\n  \"ownerid\" : \"your-user-id\",\r\n  \"clientID\": \"the-invite-app-id\",\r\n  \"prefix\": \"+\",\r\n  \"functions\": [],\r\n  \"commandInhibitors\": [\"disable\", \"permissions\", \"missingBotPermissions\"],\r\n  \"dataHandlers\": [],\r\n  \"clientOptions\": {\r\n    \"fetchAllMembers\": true\r\n  }\r\n});\r\n```\r\n\r\nThen, run the following in your folder:\r\n\r\n```\r\nnpm install\r\nnode app.js\r\n```\r\n\r\n> Requires Node 6 or higher (because discord.js requires that), also requires Discord.js v10 (currently #indev), installed automatically with `npm install`.\r\n\r\n## Quick & Dirty Reference Guide\r\n> For creating your own pieces\r\n\r\nEssentially, the way Komada works is that we have *core* pieces (functions, events, commands, etc) loaded automatically. \r\nBut you can add your own pieces easily by adding files to your *local* folders (which are created on first load)\r\n\r\nThese pieces are: \r\n- **Commands** which add in-chat functionality to your bot\r\n- **functions** which can be used by other pieces or anywhere in the bot.\r\n- **dataHandlers** which are database connectors (in progress at the moment)\r\n\r\n### Creating a new command\r\n\r\nNew commands are created in the `./commands/` folder, where subfolders are\r\nthe categories offered in the help command. For instance adding `./commands/Misc/test.js`\r\nwill create a command named `test` in the `Misc` category. Subcategories can\r\nalso be created by adding a second folder level.\r\n\r\n> If a command is present both in the *core* folders and your client folders, \r\nyour command will override the core one. This can let you modify the core\r\nbehaviour. Note also that you cannot have more than one command with the same name.\r\n\r\n```js\r\nexports.run = (client, msg. [...args]) => {\r\n  // Place Code Here\r\n};\r\n\r\nexports.conf = {\r\n  enabled: true,\r\n  guildOnly: true,\r\n  aliases: [],\r\n  permLevel: 0,\r\n  botPerms: [],\r\n  requiredFuncs: []\r\n};\r\n\r\nexports.help = {\r\n  name: \"name\",\r\n  description: \"Command Description\",\r\n  usage: \"\",\r\n  usageDelim: \"\"\r\n};\r\n```\r\n\r\n`[...args]` represents a variable number of arguments give when the command is\r\nrun. The name of the arguments in the array (and their count) is determined\r\nby the `usage` property and its given arguments.\r\n\r\n**Non-obvious options**: \r\n- **enabled**: Set to false to completely disable this command, it cannot be forecefully enabled.\r\n- **aliases**: Array of aliases for the command, which will *also* trigger it.\r\n- **permLevel**: Permission level, controlled via `./functions/permissionLevel.js`\r\n- **botPerms**: An array of permission strings (such as `\"MANAGE_MESSAGES\"`) required for the command to run.\r\n- **requiredFuncs**: An array of function names required for this command to execute (dependency)\r\n- **usage**: The usage string as determined by the Argument Usage (see below)\r\n\r\n#### Command Arguments\r\n\r\n**Usage Structure**\r\n\r\n`<>` required argument, `[]` optional argument\r\n`<Name:Type{min,max}>`\r\n\r\n- **Name** Mostly used for debugging message, unless the type is Litteral in which it compares the argument to the name.\r\n- **Type** The type of variable you are expecting\r\n- **Min, Max** Minimum or Maximum for a giving variable (works on strings in terms of length, and on all types of numbers in terms of value) You are allowed to define any combination of min and max. Omit for none, `{min}` for min, `{,max}` for max.\r\n- **Special Repeat Tag** `[...]` will repeat the last usage optionally until you run out of arguments. Useful for doing something like `<SearchTerm:str> [...]` which will allow you to take as many search terms as you want, per your Usage Deliminator.\r\n\r\n**Usage Types**\r\n\r\n- `literal` : Literally equal to the Name. This is the default type if none is defined.\r\n- `str`, `string` : Strings\r\n- `int`, `integer` : Integers\r\n- `num`, `number`, `Float` : Floating point numbers\r\n- `url` : a url\r\n- `msg`, `message` : A message object returned from the message id (now using fetchMessage as of d3d498c99d5eca98b5cbcefb9838fa7d96f17c93)\r\n- `channel` : A channel object returned from the channel id or channel tag\r\n- `guild` : A guild object returned from the guild id\r\n- `user`, `mention` : A user object returned from the user id or mention\r\n \r\n### Creating an event\r\n\r\nEvents are placed in `./events/` and their filename must be `eventName.js`.\r\nIf a conflicting event is present in both the core and your client, *both* are\r\nloaded and will run when that event is triggered.\r\n\r\nTheir structure is the following :\r\n\r\n```js\r\nexports.run = (client, [...args]) => {\r\n  // event contents\r\n};\r\n```\r\n\r\nWhere `[...args]` is arguments you would *normally* get from those events.\r\nFor example, while the `ready` event would only have `(client)`, the \r\n`guildMemberAdd` event would be `(guild, member)`.\r\n\r\n### Creating a function\r\n\r\nFunctions are available throughout the system, from anywhere. Since they are the\r\nfirst thing loaded, every other piece can access them. Functions are loaded as\r\ncore first, and if your code contains a function of the same name it overrides\r\nthe core function.\r\n\r\nTheir structure is somewhat freeform, in that they can contain a single function,\r\nor they may be a module composed of more than one functions as a module. It's\r\nnot supposed to, but let's keep it between you and me, alright?\r\n\r\n```js\r\nmodule.exports = (str) => {\r\n  return str.replace(/\\w\\S*/g, function(txt) {\r\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\r\n  });\r\n};\r\n```\r\n\r\nThe arguments are arbitrary - just like a regular function. It may, or may not,\r\nreturn anything. Basically any functions. You know what I mean.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}