{
  "name": "Komada",
  "tagline": "Komada: Croatian for `pieces`, is a modular bot system including reloading modules and easy to use custom commands.",
  "body": "# Komada\r\n\r\n[![Discord](https://discordapp.com/api/guilds/234357395646578688/embed.png)](https://discord.gg/bRCvFy9)\r\n[![npm](https://img.shields.io/npm/v/komada.svg?maxAge=3600)](https://www.npmjs.com/package/komada)\r\n[![npm](https://img.shields.io/npm/dt/komada.svg?maxAge=3600)](https://www.npmjs.com/package/komada)\r\n[![David](https://img.shields.io/david/eslachance/komada.svg?maxAge=3600)](https://david-dm.org/eslachance/komada)\r\n\r\n> \"Stay a while, and listen!\"\r\n\r\nKomada is a modular framework for bots built on top of [Discord.js](https://github.com/hydrabolt/dicord.js). It offers an extremely easy installation, downloadable commands, and a framework to build your own commands, modules, and functions.\r\n\r\n## Installing Komada\r\n\r\nTime to take the plunge! Komada is on NPM and can be easily installed.\r\n\r\n> I assume you know how to open a command prompt in a folder where you want to install this. Please don't prove me wrong.\r\n\r\n```\r\nnpm install --save komada\r\n```\r\n\r\nCreate a file called `app.js` (or whatever you prefer) which will initiate and configure Komada.\r\n\r\n```js\r\nconst komada = require('komada');\r\nkomada.start({\r\n  \"botToken\": \"your-bot-token\",\r\n  \"ownerid\" : \"your-user-id\",\r\n  \"clientID\": \"the-invite-app-id\",\r\n  \"prefix\": \"+\",\r\n  \"clientOptions\": {\r\n    \"fetchAllMembers\": true\r\n  }\r\n});\r\n```\r\n\r\n> For all you selfbot users out there, you can add a option ('selfbot': true) to have Komada enabled for selfbot usage. i.e. only respond to commands from you.\r\n\r\nThen, run the following in your folder:\r\n\r\n```\r\nnpm install\r\nnode app.js\r\n```\r\n\r\n> Requires Node 6 or higher (because Discord.js requires that), also requires Discord.js v10, installed automatically with `npm install`.\r\n\r\n## Quick & Dirty Reference Guide\r\n> For creating your own pieces\r\n\r\nEssentially, the way Komada works is that we have *core* pieces (functions, events, commands, etc.) loaded automatically.\r\nBut you can add your own pieces easily by adding files to your *local* folders (which are created on first load).\r\n\r\nThese pieces are:\r\n- **commands** which add in-chat functionality to your bot.\r\n- **functions** which can be used by other pieces or anywhere in the bot.\r\n- **inhibitors** which are used to check if a command should be run or not.\r\n- **monitors** which are used to check a message before it's a command.\r\n- **events**\r\n- **dataProviders** which are database connectors (in progress at the moment).\r\n\r\n### Creating a new command\r\n\r\nNew commands are created in the `./commands/` folder, where subfolders are\r\nthe categories offered in the help command. For instance adding `./commands/Misc/test.js`\r\nwill create a command named `test` in the `Misc` category. Subcategories can\r\nalso be created by adding a second folder level.\r\n\r\n> If a command is present both in the *core* folders and your client folders,\r\nyour command will override the core one. This can let you modify the core\r\nbehavior. Note also that you cannot have more than one command with the same name.\r\n\r\n```js\r\nexports.run = (client, msg, [...args]) => {\r\n  // Place Code Here\r\n};\r\n\r\nexports.conf = {\r\n  enabled: true,\r\n  guildOnly: true,\r\n  aliases: [],\r\n  permLevel: 0,\r\n  botPerms: [],\r\n  requiredFuncs: []\r\n};\r\n\r\nexports.help = {\r\n  name: \"name\",\r\n  description: \"Command Description\",\r\n  usage: \"\",\r\n  usageDelim: \"\"\r\n};\r\n```\r\n> Tip: If you need something created before the command is ever ran, you can specify\r\nexports.init = (client) => {...} to make Komada run that portion of code beforehand.\r\n\r\n`[...args]` represents a variable number of arguments give when the command is\r\nrun. The name of the arguments in the array (and their count) is determined\r\nby the `usage` property and its given arguments.\r\n\r\n**Non-obvious options**:\r\n- **enabled**: Set to false to completely disable this command, it cannot be forcefully enabled.\r\n- **aliases**: Array of aliases for the command, which will *also* trigger it.\r\n- **permLevel**: Permission level, controlled via `./functions/permissionLevel.js`.\r\n- **botPerms**: An array of permission strings (such as `\"MANAGE_MESSAGES\"`) required for the command to run.\r\n- **requiredFuncs**: An array of function names required for this command to execute (dependency).\r\n- **usage**: The usage string as determined by the Argument Usage (see below).\r\n\r\n#### Command Arguments\r\n\r\n**Usage Structure**\r\n\r\n`<>` required argument, `[]` optional argument\r\n`<Name:Type{min,max}>`\r\n\r\n- **Name** Mostly used for debugging message, unless the type is Literal in which it compares the argument to the name.\r\n- **Type** The type of variable you are expecting.\r\n- **Min, Max** Minimum or Maximum for a giving variable (works on strings in terms of length, and on all types of numbers in terms of value) You are allowed to define any combination of min and max. Omit for none, `{min}` for min, `{,max}` for max.\r\n- **Special Repeat Tag** `[...]` will repeat the last usage optionally until you run out of arguments. Useful for doing something like `<SearchTerm:str> [...]` which will allow you to take as many search terms as you want, per your Usage Delimiter.\r\n\r\n**Usage Types**\r\n\r\n- `literal` : Literally equal to the Name. This is the default type if none is defined.\r\n- `str`, `string` : Strings.\r\n- `int`, `integer` : Integers.\r\n- `num`, `number`, `Float` : Floating point numbers.\r\n- `boolean`, : A true or false statement.\r\n- `url` : A URL.\r\n- `msg`, `message` : A message object returned from the message ID (now using fetchMessage as of d3d498c99d5eca98b5cbcefb9838fa7d96f17c93).\r\n- `role` : A role object returned from the role ID or mention.\r\n- `channel` : A channel object returned from the channel ID or channel tag.\r\n- `guild` : A guild object returned from the guild ID.\r\n- `user`, `mention` : A user object returned from the user ID or mention.\r\n\r\n### Creating an event\r\n\r\nEvents are placed in `./events/` and their filename must be `eventName.js`.\r\nIf a conflicting event is present in both the core and your client, *both* are\r\nloaded and will run when that event is triggered.\r\n\r\nTheir structure is the following :\r\n\r\n```js\r\nexports.run = (client, [...args]) => {\r\n  // event contents\r\n};\r\n```\r\n\r\nWhere `[...args]` are arguments you would *normally* get from those events.\r\nFor example, while the `ready` event would only have `(client)`, the\r\n`guildMemberAdd` event would be `(guild, member)`.\r\n\r\n### Creating a function\r\n\r\nFunctions are available throughout the system, from anywhere. Since they are the\r\nfirst thing loaded, every other piece can access them. Functions are loaded as\r\ncore first, and if your code contains a function of the same name it overrides\r\nthe core function.\r\n\r\nTheir structure is somewhat freeform, in that they can contain a single function,\r\nor they may be a module composed of more than one functions as a module. It's\r\nnot supposed to, but let's keep it between you and me, alright?\r\n\r\n```js\r\nmodule.exports = (str) => {\r\n  return str.replace(/\\w\\S*/g, function(txt) {\r\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\r\n  });\r\n};\r\n```\r\n\r\nThe arguments are arbitrary - just like a regular function. It may, or may not,\r\nreturn anything. Basically any functions. You know what I mean.\r\n\r\n### Creating a inhibitors\r\n\r\nInhibitors are only ran on commands. They are used to check a variety of conditions\r\nbefore a command is ever ran, such as checking if a user has the right amount of permissions\r\nto use a command. Inhibitors are loaded as core first, and if your code contains a inhibitor\r\nof the same name it overrides the core inhibitor.\r\n\r\nTheir structure is restricted, meaning to work they must be defined exactly like this.\r\n\r\n```js\r\nexports.conf = {\r\n  enabled: true,\r\n  spamProtection: false,\r\n};\r\n\r\nexports.run = (client, msg, cmd) => {\r\n  // code here\r\n}\r\n```\r\n\r\n> Note: The order does not matter.\r\n\r\n### Creating a monitors\r\n\r\nMonitors are special in that they will always run on any message. This is particularly\r\nuseful when you need to do checking on the message, such as checking if a message\r\ncontains a vulgar word (profanity filter). They are almost completely identical to\r\ninhibitors, the only difference between one is ran on the message, and the other\r\nis ran on the command. Monitors are loaded as core first, and if your code contains\r\na monitor of the same name it overrides the core monitor.\r\n\r\nTheir structure is identical to inhibitors, being the only difference is that you\r\ndon't pass a command parameter to them.\r\n\r\n```js\r\nexports.conf = {\r\n  enabled: true,\r\n  spamProtection: false,\r\n};\r\n\r\nexports.run = (client, msg) => {\r\n  // code here\r\n};\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}